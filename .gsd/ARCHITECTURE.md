# Architecture

> Auto-generated by /map on 2026-01-19

## Overview

**wrenchbox** is a browser-based music creation engine inspired by Incredibox and Sprunki. It's a completed project (6 phases) that enables drag-and-drop sound mixing with progressive "horror mode" corruption mechanics. The architecture is intentionally simple - vanilla JavaScript with Tone.js for audio, no build tools required.

**Design Philosophy:** Each development phase (1-6) produced a working, playable build. The codebase is learning-focused with clear separation of concerns and extensive inline documentation.

```
┌─────────────────────────────────────────────────────┐
│              Browser Entry (index.html)             │
│              ↓ loads scripts in order               │
├─────────────────────────────────────────────────────┤
│           Core Layer (Audio & Sequencing)           │
│    AudioEngine, Sequencer, SampleManager            │
├─────────────────────────────────────────────────────┤
│         Feature Layer (Bonus & Horror)              │
│  BonusManager, CorruptionManager, HorrorEffects     │
├─────────────────────────────────────────────────────┤
│          Data Layer (Configuration)                 │
│      ThemeLoader, samples.js, bonuses.js            │
├─────────────────────────────────────────────────────┤
│              UI Layer (Interaction)                 │
│          DragDrop, BonusOverlay                     │
├─────────────────────────────────────────────────────┤
│        Main Coordinator (main.js)                   │
│    State management, event orchestration            │
└─────────────────────────────────────────────────────┘
```

## Components

### Core Layer

#### AudioEngine.js
- **Purpose:** Tone.js wrapper managing audio sources (samples or synth fallback)
- **Location:** `src/core/AudioEngine.js` (386 lines)
- **Dependencies:** Tone.js (CDN), SampleManager
- **Key Methods:**
  - `createSource()` - Creates Tone.Player (sample) or synth
  - `muteSlot()`, `soloSlot()` - Per-slot volume control
  - `createSynth()` - Generates Tone.js synths (MembraneSynth, NoiseSynth, etc.)
- **Exports:** Global `audioEngine` singleton

#### Sequencer.js
- **Purpose:** Pattern-based timing using Tone.Transport
- **Location:** `src/core/Sequencer.js` (286 lines)
- **Dependencies:** AudioEngine, Tone.js
- **Key Methods:**
  - `initializeFromTheme()` - Loads sound definitions from theme JSON
  - `startPattern()` / `stopPattern()` - Controls per-slot playback
  - `setBpm()` - Global tempo control
- **Pattern System:** Supports both sample loops (Tone.Player) and synth sequences (Tone.Sequence)

#### SampleManager.js
- **Purpose:** Audio file loading and preloading
- **Location:** `src/core/SampleManager.js`
- **Dependencies:** Tone.js
- **Features:**
  - Registers sample URLs from theme config
  - Preloads with progress callback
  - Graceful fallback to synths if unavailable
- **Exports:** Global `sampleManager` singleton

### Feature Layer

#### BonusManager.js
- **Purpose:** Combo detection system
- **Location:** `src/core/BonusManager.js`
- **Algorithm:** Set comparison - checks if active sounds ⊇ required sounds
- **State:** Tracks triggered bonuses (repeatable vs one-time)
- **Callbacks:** `onBonusTriggered`, `onBonusEnded`

#### CorruptionManager.js
- **Purpose:** Horror mode cellular automata spread
- **Location:** `src/core/CorruptionManager.js`
- **Algorithm:** 
  - Per-slot corruption level (0-100%)
  - Spreads to neighbors via probability (`spreadRate`)
  - Timed ticks (`tickInterval`)
- **Trigger:** Placing "cursed" sound activates corruption
- **Callbacks:** `onCorruptionChanged`, `onHorrorModeStart`, `onHorrorModeEnd`

#### HorrorEffects.js
- **Purpose:** Audio/visual transformation based on corruption level
- **Location:** `src/core/HorrorEffects.js`
- **Audio Effects:** PitchShift → BitCrusher → FrequencyShifter → Distortion (Tone.js)
- **Visual Effects:** CSS filters (hue-rotate, saturate, invert, brightness)
- **Tiers:** 
  - Low (25-49%): Subtle detuning, hue shift
  - Medium (50-74%): Bitcrushing, desaturation
  - High (75-99%): Ring mod + distortion, chromatic aberration
  - Full (100%): Max effects, full inversion

### Data Layer

#### ThemeLoader.js
- **Purpose:** JSON configuration loading and injection
- **Location:** `src/data/ThemeLoader.js`
- **Features:**
  - Loads `themes/{theme-id}/theme.json`
  - Injects CSS variables (`--color-primary`, etc.)
  - Provides accessors for sounds, bonuses, corruption config
  - URL parameter support: `?theme=my-theme`
- **Exports:** Global `themeLoader` singleton

#### samples.js
- **Purpose:** Hardcoded sample configuration (fallback)
- **Location:** `src/data/samples.js`
- **Format:** Maps sound names to `{ url, urlB, type, loopStart, loopEnd }`

#### bonuses.js
- **Purpose:** Hardcoded bonus configuration (fallback)
- **Location:** `src/data/bonuses.js`
- **Format:** Array of `{ id, title, requiredSounds, animation, duration }`

### UI Layer

#### DragDrop.js
- **Purpose:** HTML5 Drag and Drop handler
- **Location:** `src/ui/DragDrop.js` (172 lines)
- **Features:**
  - Drag palette icons → slots (assign sound)
  - Drag slots → slots (move sound)
  - Drag slots → palette (remove sound)
  - Visual feedback (`.dragging`, `.drag-over`, `.remove-zone-active`)
- **Callbacks:** `onDrop`, `onRemove`

#### BonusOverlay.js
- **Purpose:** Animated overlay for bonus triggers
- **Location:** `src/ui/BonusOverlay.js`
- **Animations:** pulse, wave, shake, disco, fireworks (CSS keyframes + particles)
- **Duration:** Configurable per bonus

### Main Coordinator

#### main.js
- **Purpose:** Application initialization, state management, event orchestration
- **Location:** `src/main.js` (708 lines)
- **State Management:**
  ```javascript
  state = {
    slots: [],           // { id, soundName, element, active, muted, soloed }
    initialized: false,
    soloedSlotId: null
  }
  ```
- **Lifecycle:**
  1. Start overlay click → `handleStart()`
  2. Load theme → `themeLoader.load()`
  3. Initialize audio → `audioEngine.init()`, `new Sequencer()`
  4. Setup systems → `setupBonusSystem()`, `setupHorrorSystem()`
  5. Create UI → `createSlots()`, `createSoundIcons()`
  6. Setup interactions → `setupDragDrop()`, `setupEventListeners()`

## Data Flow

### Sound Assignment Flow
1. User drags icon from palette → `DragDrop.onDrop()` triggered
2. `main.js` calls `assignSoundToSlot(slotId, soundName)`
3. Update state: `slot.soundName = soundName`, `slot.active = true`
4. Start pattern: `startPatternQuantized()` schedules `sequencer.startPattern()` at next bar
5. Sequencer determines mode (sample or synth) via `audioEngine.createSource()`
6. Audio starts playing: Tone.Player loops or Tone.Sequence triggers synth
7. Check for bonus: `checkForBonus()` → `bonusManager.checkBonus(activeSounds)`
8. Check for horror: If sound is cursed → `corruptionManager.startCorruption(slotId)`

### Horror Mode Spread Flow
1. Cursed sound placed → `corruptionManager.startCorruption(slotId)`
2. Timer tick (every 2000ms) → spread to neighbors
3. `corruptionManager.corruption.set(slotId, newLevel)`
4. Callback `onCorruptionChanged` → `horrorEffects.applyVisualCorruption()`
5. Audio effects applied via Tone.js effect chain
6. CSS filters applied to slot element
7. Global ambiance updated based on max corruption level

### Theme Loading Flow
1. `themeLoader.load(themeId)` fetches `themes/{id}/theme.json`
2. Extract sections: meta, colors, sounds, bonuses, corruption, ui
3. `applyColors()` injects CSS variables to `:root`
4. `applyBackground()` sets body background
5. `Sequencer.initializeFromTheme(sounds)` merges theme sounds with defaults
6. `bonusManager.registerBonuses(bonuses)`
7. `corruptionManager.applyThemeConfig(corruption)`
8. Main app uses theme config for slot count, icons, etc.

## Integration Points

| External Service | Type | Purpose |
|------------------|------|---------|
| Tone.js (CDN) | JavaScript Library | Audio synthesis, scheduling, effects |
| Browser Audio Context | Web API | Audio playback (unlocked via user gesture) |
| HTML5 Drag & Drop | Web API | User interaction for sound assignment |
| LocalStorage | Web API | Potential future use (not currently used) |

## Conventions

### Naming
- **Classes:** PascalCase (`AudioEngine`, `Sequencer`, `DragDrop`)
- **Instances:** camelCase (`audioEngine`, `sequencer`, `dragDrop`)
- **Global singletons:** Exported via `const globalName = new ClassName()`
- **Private methods:** No convention (all public in class)

### Structure
- **Phases preserved:** Historical snapshots in `phases/01-foundation/`, `phases/02-incredibox/`, etc.
- **Script loading:** Order-dependent (index.html loads in sequence, no modules)
- **Configuration:** JSON-driven via `theme.json`, fallback to hardcoded JS configs

### Testing
- **No automated tests** present in codebase
- **Manual testing:** Run local server, test in browser
- **DEVLOG.md** tracks testing notes per phase

### Audio
- **BPM:** Configurable via theme (default 120 BPM)
- **Key:** Configurable via theme (default C Minor)
- **Quantization:** All sound starts quantized to next bar (`Tone.Transport.nextSubdivision('1m')`)
- **Loop length:** Configurable via theme (`loopBars`, default 4 bars)

### Error Handling
- **Graceful fallback:** Sample loading fails → use synths
- **File protocol:** Shows warning in console, continues with synths
- **Missing assets:** Uses emoji fallbacks for icons

## Technical Debt

- [ ] No package.json - dependencies loaded via CDN (fragile, no versioning)
- [ ] No build process - scripts concatenated manually in index.html
- [ ] No automated tests - manual testing only
- [ ] No TypeScript - vanilla JS (potential for runtime errors)
- [ ] Global singletons - not testable, state not isolated
- [ ] No error boundaries - uncaught errors crash entire app
- [ ] File loading order - brittle dependency in script tags
- [ ] No mobile touch support yet (Phase 7 planned)
- [ ] No recording/export feature yet (Phase 7 planned)

## Performance Considerations

- **Audio scheduling:** Tone.Transport handles lookahead (25ms interval, 100ms ahead)
- **Sample loading:** Preloaded on start, ~50-100KB per loop
- **Horror effects:** Effect chains created per slot (CPU increases with active slots)
- **Visual updates:** CSS filters applied on corruption change (60fps capable)
- **Memory:** ~300-400MB RAM typical (samples + audio graph)

## Future Enhancements (Phase 7)

From PLAN.md, future work includes:
- Session recording (capture user actions)
- Playback recording
- Export as audio file (Tone.Recorder)
- Share link generation (encode state in URL)
- Mobile touch support
- Fullscreen mode
- Accessibility (reduce motion, visual indicators)
